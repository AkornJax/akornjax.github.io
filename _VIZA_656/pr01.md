---
layout: art
title: Project 01
subtitle: 2D Diffuse Shading & Specular Highlight with Normal Maps

---

<link href="/assets/css/viza656.css" rel="stylesheet" type = "text/css">
<script src="//code.jquery.com/jquery-1.10.2.js"></script>
<script src="//code.jquery.com/ui/1.11.4/jquery-ui.js"></script>

<div class="container">
    <body onmousemove="mouse_position(event)">
    <canvas id="canvas"></canvas>
    <div id="ui">
        <button id="uiheader">Click here to move </button>
        <div class="slider-name"> Dark Opacity</div>
        <div class="value">0</div>
        <input id="darkImageOpacity" class="slider" type="range" min="0" max="1" step=".001" value=".5" oninput="myFunction(this.id)"> 
            <br>
        <div class="slider-name"> Light Opacity</div>
        <div class="value">0</div>
        <input id="lightImageOpacity" class="slider" type="range" min="0" max="1" step=".001" value=".5" oninput="myFunction(this.id)">
            <br>
               <div class="slider-name"> Normal Opacity</div>
        <div class="value">0</div>
        <input id="normalImageOpacity" class="slider" type="range" min="0" max="1" step=".001" value=".5" oninput="myFunction(this.id)">
        <br>
        <div class="slider-name"> Light Intensity</div>
        <div class="value">0</div>
        <input id="lightIntensity" class="slider" type="range" min="0" max="1" step=".001" value=".5" oninput="myFunction(this.id)">
        <br>
        <div class="slider-name"> Light Color</div>
        <div class="value">0</div>
        <input id="lightColor" class="slider" type="range" min="0" max="1" step=".001" value=".5" oninput="myFunction(this.id)">
        <br>
            <button id="screenshot" type="button">Save...</button>
        
    </div>
    </body>
</div>
<!-- vertex shader -->
<script  id="vertex-shader-2d" type="x-shader/x-vertex">#version 300 es
// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
in vec2 a_position;
in vec2 a_texCoord;

// Used to pass in the resolution of the canvas
uniform vec2 u_resolution;

// Used to pass the texture coordinates to the fragment shader
out vec2 v_texCoord;

// all shaders have a main function
void main() {

  // convert the position from pixels to 0.0 to 1.0
  vec2 zeroToOne = a_position / u_resolution;

  // convert from 0->1 to 0->2
  vec2 zeroToTwo = zeroToOne * 2.0;

  // convert from 0->2 to -1->+1 (clipspace)
  vec2 clipSpace = zeroToTwo - 1.0;

  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

  // pass the texCoord to the fragment shader
  // The GPU will interpolate this value between points.
  v_texCoord = a_texCoord;
}
</script>
<!-- fragment shader -->
<script  id="fragment-shader-2d" type="x-shader/x-fragment"> #version 300 es
// fragment shaders don't have a default precision so we need
// to pick one. highp is a good default. It means "high precision"
precision highp float;

// our texture
uniform sampler2D u_imageDark;
uniform sampler2D u_imageLight;
uniform sampler2D u_imageNormal;
uniform float f_darkImageOpacity;
uniform float f_lightImageOpacity;
uniform float f_normalImageOpacity;

//light
uniform vec2 u_lightPosition;

// the texCoords passed in from the vertex shader.
in vec2 v_texCoord;

// we need to declare an output for the fragment shader
out vec4 outColor;

void main() {
    vec4 colorDark = texture(u_imageDark, v_texCoord) * f_darkImageOpacity;
    vec4 colorLight = texture(u_imageLight, v_texCoord) * f_lightImageOpacity;
    vec4 colorNormal = texture(u_imageNormal, v_texCoord) * f_normalImageOpacity;

  outColor = colorDark + colorLight + colorNormal ;
}
</script><!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See https://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
and https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
<script src="https://webgl2fundamentals.org/webgl/resources/m3.js"></script>
<script src="https://webgl2fundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="/assets/js/pr01.js"></script>

<!-- SliderUpdate.js-->
<script>
  function myFunction(id)
  {
     //Create variables
      var propertyToModify = id;
      var newValue =document.getElementById(id).value;
      var target =document.getElementById(id).previousElementSibling;

      //Assign value to ui
      target.innerHTML = newValue;
      //Assign value to variable for frag shader
      window[propertyToModify] = newValue;
   
      //Update Render
      updateNow();
  }
</script>

<!-- Draggable.js-->
<script>
  //TODO figure out why it needs to be a button to be dragged. Most likely has to do with z-depth?
  // Make the DIV element draggable:
dragElement(document.getElementById("ui"));

function dragElement(elmnt) {
var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
if (document.getElementById(elmnt.id + "header")) {
  // if present, the header is where you move the DIV from:
  document.getElementById(elmnt.id + "header").onmousedown = dragMouseDown;
} else {
  // otherwise, move the DIV from anywhere inside the DIV:
  elmnt.onmousedown = dragMouseDown;
}

function dragMouseDown(f) {
  e = f;
  e.preventDefault();
  // get the mouse cursor position at startup:
  pos3 = e.clientX;
  pos4 = e.clientY;
  document.onmouseup = closeDragElement;
  // call a function whenever the cursor moves:
  document.onmousemove = elementDrag;
}

function elementDrag(e) {
  e = e;
  e.preventDefault();
  // calculate the new cursor position:
  pos1 = pos3 - e.clientX;
  pos2 = pos4 - e.clientY;
  pos3 = e.clientX;
  pos4 = e.clientY;
  // set the element's new position:
  elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
  elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
}

function closeDragElement() {
  // stop moving when mouse button is released:
  document.onmouseup = null;
  document.onmousemove = null;
}
}
</script>

<!--SaveFile.js-->
<script>
      const elem = document.querySelector('#screenshot');
  elem.addEventListener('click', () => {
    canvas.toBlob((blob) => {
      saveBlob(blob, `screencapture-${canvas.width}x${canvas.height}.png`);
    });
  });
  const saveBlob = (function() {
    const a = document.createElement('a');
    document.body.appendChild(a);
    a.style.display = 'none';
    return function saveData(blob, fileName) {
       const url = window.URL.createObjectURL(blob);
       a.href = url;
       a.download = fileName;
       a.click();
    };
  }());

</script>

<!-- Mouse Tracking-->
<script>
  function mouse_position(e)
  {
    //https://stackoverflow.com/questions/42309715/how-to-correctly-pass-mouse-coordinates-to-webgl
    var pos = getNoPaddingNoBorderCanvasRelativeMousePosition(e, gl.canvas);
  // pos is in pixel coordinates for the canvas.
  // so convert to WebGL clip space coordinates
  const x = pos.x / gl.canvas.width  *  2 - 1;
  const y = pos.y / gl.canvas.height * -2 + 1;
     mousePosition[0] = x;
     mousePosition[1] = y;
     //console.log( mousePosition);
    updateNow();
  }
</script>